---
layout: default
title: 程序设计基础
category: MOOC
---

哈尔滨工业大学

[TOC]

---

### 第一周 计算机基础

十进制数转换为二进制：
- 整数：除以2逆向取余
- 小数：乘以2顺向取整

整数：补码
- 正数：原码、反码、补码一样
- 负数：补码，将二进制的绝对制按位取反，再加1，
有符号数：1为负，0为正
无符号数：

浮点数：

补码的来源和好处？

二进制数：
- 加法规则：0+0=0, 0+1=1, 1+0=1, 1+1=10
- 乘法规则：0·0=0, 0·1=0, 1·0=0, 1·1=1

**字长 (word size, word width, or word length)**
计算机在同一时间内处理的一组二进制数称为一个计算机的“字”，而这组二进制数的位数就是“字长”。
A word is a fixed-sized piece of data handled as a unit by the instruction set or the hardware of the processor. The number of bits in a word (the word size, word width, or word length) is an important characteristic of any specific processor design or computer architecture.

### 第二周  程序设计方法基础

算法（Algorithm）——为解决一个具体问题而采取确定的有限的操作步骤，仅指计算机能执行的算法。

程序设计是一门艺术，主要体现在

- 算法设计——程序的灵魂
- 结构设计——程序的肉体

揭示面向过程的程序本质的公式

- 算法 + 数据结构 = 程序

**算法的特性**

- 有穷性（Finiteness）
    - 在合理的时间内完成
- 确定性（Definiteness）
    - 无歧义，能有效执行，且能得到确定的结果
    - 有效性（Effectiveness）
- 允许没有输入或有多个输入（Input）
- 必须有一个或多个输出 （Output）

**常用的算法描述方法**

- 自然语言（Natural Language）
- 伪码（Pseudocode）表示
- 传统的流程图（Flowchart）
- N-S结构化流程图

**流程图符号Symbol**
Semantic
处理框（Process）
输入/输出(Input/Output)
判断框(Decision，Test)
连接符(Connector）
流程线(Flow of activities)

```flow
st=>start: Start:>https://www.zybuluo.com
io=>inputoutput: verification
op=>operation: Your Operation
cond=>condition: Yes or No?
sub=>subroutine: Your Subroutine
e=>end

st->io->op->cond
cond(yes)->e
cond(no)->sub->io
```

顺序结构（Sequential Structure）
选择结构（分支结构）
- 单分支选择结构（Single Selection）
- 双分支选择结构（Double Selection）
- 多分支选择结构（Multiple Selection）

**循环结构**
如何控制循环的结束？
- 条件控制的循环（Condition Controlled Loop）
 由一个给定的条件来控制
- 计数控制的循环（Counter Controlled Loop）
 重复处理的次数是已知的

两种实现方法

- while
- do-while

循环体（Body of Loop）

**选择循环结构的一般原则**

|已知|结构选择|
|----|--------|
|循环次数已知|计数控制的循环结构|
|循环次数未知，循环的次数由一个给定的条件来控制|条件控制的循环结构|
|循环体至少要执行一次|直到型循环|


累加求和
- 主要操作：sum = sum + term
    - 累加求和变量sum初始化为0——从第1项开始累加
    - 或者初始化为累加项的第1项——从第2项开始累加
- 累乘求积
    - 主要操作：p = p * term
    - 累乘求积变量p初始化为1

- 累加项的前后项之间无关
    - 1*2*3 + 3*4*5 +… + 99*100*101
    - term = i*(i+1)*(i+2)
    - sum = sum + term
    - i = i + 2 (i = 1,3,…,99)
    - 单独计算累加项p
    - sum = sum + p
- 累加项的前后项之间有关
    - x0 + x1 + x2 + …+ xn
    - term = term * x
    - sum = sum + term
    - term初值为1
    - • 单独计算累加项p
• 利用前项计算后项
• sum = sum + p

嵌套循环 nested loop
    
- 嵌套循环
    - 外层循环每执行一次，内层循环都要完整的执行一遍(总的循环次数=内层循环次数x外层循环次数)
    - 内层和外层循环控制变量不能同名
- 嵌套循环的设计方法
    - 由内到外
    - 由外到内
    
**循环不变式**

- 如何确定循环过程是正确的？
- 何为循环不变式？

循环不变 loop invariant

### 第三周 程序设计方法基础2

**RAPTOR** (The Rapid Algorithmic Prototyping Tool for Ordered Reasoning)--用于有序推理的快速算法原型工具

有向图 Directed Graph
自底向上 Down-Top
自顶向下 Top-Down 逐步求精 Stepwise Refinement




#### 结构化程序设计（Structured Programming）——搭积木

- 结构化程序设计（Structured Programming）是一种程序设计的原则和方法
- 它限制和避免使用goto语句，采用“自顶向下、逐步求精”方法进行程序设计
- 按照这种原则和方法设计出的程序的特点为：结构清晰、容易阅读、容易修改、容易验证
- 无论从总体上还是从每一个组成部分来看，都遵循“单入口单出口”的原则

#### 模块化程序设计（Modular Programming）——分工与合作

- 使模块内部的实现细节对外不可见，实现信息隐藏（Information Hiding）
- 限制模块的复杂性和规模
- 保证模块的相对独立性（Module Independence）和正确性

**过程抽象**

- 面向过程语言实现模块化程序设计的基本手段
- 过程抽象的结果是函数——功能抽象
- 将一个确定的完成子任务的操作序列看成一个黑箱
- 使程序员可以在不同的抽象层次上分析问题
- 通过将过程抽象为函数，实现信息隐藏和模块的可重用性

**数据抽象**

- 面向对象语言实现模块化程序设计的基本手段
- 数据抽象的结果是数据类型
- 通过封装数据和操作数据的方法并限制外部程序的访问来实现信息隐藏
 
抽象数据类型（Abstract Data Type，ADT）

- 根据施加于数据之上的操作定义类型，限定只能由这些操作来修改和观察数据值
- 强调把数据和操作封装起来，结合为一个不可分割的独立的整体
- C++语言中的类（Class）

模块的独立性：内聚度（Cohesion），耦合度（Coupling）

#### 面向对象（Object Orientation，OO）程序设计

**面向过程：**

- 以功能为核心，自顶向下，逐一实现，最终解决问题
- 把问题转化为处理步骤（过程）
- 程序 = 算法 + 数据结构

**面向对象：**

- 以对象为核心，先构造与整个系统（问题）相关的各个对象，描述他们的状态、行为，然后通过消息来调动这些对象，让他们来解决这个问题。
- 程序 = 对象 + 消息
- 面向对象将对象作为软件系统结构的基本组成单元，以主体数据为中心，将数据及其上作用的操作一起封装，以标准的接口规范对外提供服务。

**封装（Encapsulation）：**定义对象和操作，只提供抽象的接口，并隐藏它们的具体实现。
**继承（Inheritance）：**子类（也称派生类）对象拥有与其基类（也称父类）相同的全部属性和方法。
**多态性（Polymorphism）：**在基本类中定义的属性或行为被子类继承后，可以有不同的数据类型或行为特征，多态性使程序可以按照它们的共同特性来书写。

### 第四周 问题求解与算法设计基础

|策略|基本思想|应用|要点|
|----|--------|----|----|
|分治<br>Divide and Conquer|将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同，求出子问题的解，就可得到原问题的解。|归并排序、折半查找、二分法求方程等|合并是算法的关键。用分治策略设计的算法，通常用递归程序来实现|
|穷举<br>Exhaustion|<br>也称枚举法（Enumeration），列举所有可能，逐一试探|破解密码，蛮力法（Brute Force），或暴力搜索法，只适合于“有几种组合”、“是否存在”、求解不定方程等类型的问题求解，鸡兔同笼，韩信点兵|确定穷举对象和穷举范围（影响算法的时间复杂度，循环结构实现）<br>确定判定条件（符合什么条件才能成为问题的答案，分支结构实现）|
|递推|从已知的初始条件出发，依据某种递推关系，逐次推出所要计算的中间结果和最终结果|常用于按照一定的规律来计算序列中的指定项|正向顺推实例：Fibonacci反向逆推的实例：猴子吃桃问题||
|递归<br>Recursion|如果一个对象部分地由它自己组成或按它自己定义，则称它是递归的。函数/过程/子程序在运行过程中直接或间接调用自身而产生的重入现象|数学定义递归的（如计算阶乘、最大公约数和Fibonacci数列等）<br>数据结构是递归的(如队列、链表、树和图等)<br>问题的解法是递归的(如Tower of Hanoi，骑士游历、八皇后问题等)|必须包含：一般条件（General case）：由其自身定义的与原始问题类似的更小规模的子问题，它使递归过程持续进行<br>基本条件（Base case）：所描述问题的最简单的情况，它是一个能控制递归过程结束的条件|


Q: 如何存储大量的数据？
A: 数组 (Array)


|查找算法|基本思想|时间效率|
|--------|--------|--------|
|线性查找|针对未排序数据|平均情况 n/2|
|二分查找|针对已排序数据|最多所需的比较次数是第一个大于表中元素个数的2的幂次数|
|分块查找|针对按块有序、块内无序的数据|性能介于线性查找和二分查找之间|
|哈希查找||根据关键字直接计算出记录存放的地址，查找效率高|

**线性查找（顺序查找）：**从线性数据表中的第一个（或最后一个）记录开始查找，依次将记录的关键字与给定的值进行比较。当某个记录的关键字与给定的值相等时，即查找成功；反之，查完全部记录都没有与之相等的关键字，则查找失败。

**二分查找（折半查找）：**先将表的中间位置记录的关键字与查找关键字比较，如果两者相等，则查找成功，否则将表分成前、后两个子表，根据比较结果，决定查找哪个子表。

**分块查找（索引线性查找）：**将n个数据划分为 m (m ≤ n) 个数据块，每一个数据块中的数据不必有序，但块与块之间必须“按块有序”。
    - 第1步：建立一个块最大关键字表（抽取各块中的最大关键字及其块的起始地址构成索引表）在块间查找，找到数据所在的块（块与块之间“按块有序”——线性或二分查找）。
    - 第2步：在一个数据块内进行查找（块中的数据非有序——线性查找）

**哈希查找：**按关键字编址的快速检索方法，通过对记录的关键字值进行某种运算，直接求出记录的地址。哈希是hash的音译，也称散列。核心是设计哈希函数， 并构建哈希表。

**哈希冲突**
当两个不同的数据的哈希值相同时，就会发生冲突（collision）

**处理哈希冲突的常用方法**
链地址法：将哈希值相同的数据存在一个链表中。查找哈希表时，当查找到这个链表时，采用线性查找方法。

**哈希函数的典型构造方法**

- 求模取余法：
    - H(key) = key % p
    - p <= m，哈希表表长为 m
    - 余数（哈希地址）总是循环出现，呈周期性变化

### 排序算法

先对数据排序，再进行操作，可大大提高解决问题的效率。

#### 冒泡排序

原理： 比较相邻的两个数据，若顺序不对，则将其位置交换。
算法：
优化：
动画：<a href="http://www.icourse163.org/learn/HIT-1001614003?tid=1002015007#/learn/content?type=detail&id=1002615586&cid=1002868364?video=access;type=1"> <i class="icon-youtube-play"></i> </a>

#### 交换排序和选择排序

交换排序
:    第一个数分别与后面所有的数进行比较，若后面的数较小，则交换后面这个数和第一个数的位置
第二个数分别与后面所有的数进行比较，若后面的数较小，则交换后面这个数和第二个数的位置

选择排序（交换排序的优化）
:    在每一遍比较中，在剩余的待比较的数中选择一个最小的数与这个剩余序列的第1个数交换位置 

#### 插入排序和希尔排序

插入排序
:    每次将一个待排序的数据，在前面已排好序的子序列中从后向前扫描，按其值大小找到适当的位置并插入其中，直到序列中的全部数据都插入完毕为止

希尔排序（插入排序的优化，分组插入）
:    取一个小于n的整数d1作为第一个增量，把序列中的全部数据分成d1个组。所有距离为d1的倍数的数据放在同一个组中；在各组内进行直接插入排序；取第二个增量d2<d1，重复上述的分组和排序，直至所取的增量dt=1(dt<…<d2<d1)，即所有数据都放在同一组中进行直接插入排序为止。

#### 归并排序

假设待排序的数据序列中有n个数据，可以先将序列看成是由个长度为1的有序子序列组成，然后再两两子序列合并，得到一个n/2个长度为2或1（当序列中数据为奇数时会有一个子序列长度为1）的有序子序列，再两两子序列合并，如此重复，直到得到一个长度为n的有序序列为止 

#### 快速排序

1. 设置两个变量i和j，排序开始前将i和j分别初始化为1和n，这里i和j分别相当于序列的左指针和右指针；
2. 以序列中第一个数作为基准（Base），赋值给s，这里基准相当于序列分割的一个参照物；
3. 从j开始从后向前搜索，每向前搜索一步，就将j的值减去1，直到搜索到第一个小于s的数为止，将这个数和基准互换位置；
4. 从i开始从前向后搜索，每向后搜索一步，就将i的值加上1，直到搜索到第一个大于s的数为止，将这个数和基准互换位置；
5. 重复第3、4步，直到i与j相等为止。

|排序算法|时间复杂度|原理动画|
|--------|----------|--------|
|冒泡排序|||
|交换排序|||
|选择排序|||
|插入排序|||
|归并排序|||
|快速排序|||
[6分钟演示15种排序算法](http://www.bilibili.com/video/av685670/)


**时间复杂度**

- 随着n的增大，n和算法性能之间的关系称为算法的计算复杂度（Computational Complexity）
    - 时间复杂度（Time Complexity）和空间复杂度（Space Complexity）
- 算法的时间复杂度是算法的时间量度，是指执行算法所需要的计算工作量
- 一个算法花费的时间与算法中语句的执行次数是成正比的，算法的基本操作被重复执行的次数是问题规模n的某个函数f(n)，因此，算法的时间复杂度记为：T(n)=O(f(n))
- O(n2)表示算法性能随问题规模n 的平方而变化（大O记法(Big O notation)）

常用的简化方式如下：

- 删除随n值增大而对总估值不再重要的项，只保留在公式中占主导地位的项，即最高阶项
- 删除所有的常数因子。因为常数因子不影响随n增长变化的趋势，所以可以忽略
- 选择排序算法的时间复杂度由O((n2+n)/2)简化表示为O(n2)
- 常用的时间复杂度从低到高的次序：O(1) < O(logn) < O(n) < O(n2) < O(n3) < O(2n) 

|执行次数的函数|阶|非正式术语|
|---|---|:---:|
| 12 | $O(1)$ | 常数阶 |
| $2n+3$ | $O(n)$ | 线性阶 |
| $3n^2+2n+1$ | $O(n^2)$ | 平方阶 |
| $5 log_2 n + 20$ | $O(log n)$ | 对数阶 |
| $6n^3+2n^2+3n = 4$ | $O(n^3)$ | 立方阶 |
| $2^n$ | $O(2^n)$ | 指数阶 |

## Q&A

1. 对ｎ个不同的排序码进行冒泡排序，在哪种情况下排序比较的次数最多？
- [X] A. 元素无序
- [ ] B. 从大到小排列好的
- [ ] C. 元素基本有序
- [ ] D. 从小到大排列好的
2. 将数据元素{2,4,6,8,10,12,14,16,18,20}依次存放于一个一维数组中，然后采用折半查找元素12，比较过哪些数组元素?
- [ ] A. 10,14,12
- [X] B. 10,16,12
- [ ] C. 10,16,14
- [ ] D. 10,14,16

##### **问：负数采用补码有什么好处？**

1. +0 的原码：0 000 0000 0000 0000 -0 的原码： 1 000 0000 0000 0000
+0 的反码：0 000 0000 0000 0000 -0 的反码： 1 111 1111 1111 1111
+0 的补码：0 000 0000 0000 0000 -0 的补码：(1) 0 000 0000 0000 0000
其中，-0 的补码最高位的 1 因为发生了溢出所以被丢弃，因此-0 的补码是 0 000 0000 0000 0000
+0 和-0 的补码一样，这保证了 0 的表达的唯一性，也避免了存储空间的浪费（+0 和-0 如果用
原码表示就不同，那么 0 的表示就不唯一了）
2. 如果采用原码进行减法运算则运算过程如下：7-6=00 00 00 00 00 00 01 11-00 00 00 00 00
00 01 10=00 00 00 00 00 00 00 01。此时计算机需要记录减法运算规则，并对符号位进行单独处理，
复杂。采用补码运算则将减法转化为加法，不需要额外记录减法运算规则，符号位与数值位一同
运算，不需要单独处理，简单明了。
补码：7+（-6）=00 00 00 00 00 00 01 11+11 11 11 11 11 11 10 10=00 00 00 00 00 00 00 01

##### **问：浮点数采用非规格化技术，则表数范围是多少？**
解答：非零情况下不考虑正负，尾数的最小数应该为 0000 0000 0000 0000 0000 001，最大为 1111
1111 1111 1111 1111 111，所以尾数的范围为 2^(-23) ~ 1- 2^(-24),指数部分表数范围不变，如果采
用补码表示，则还是 0000 0000~1111 1111，即-2^7~2^7-1 , 所以整体的表数范围为：±
2^(-23)*2^(-128) ~±（1- 2^(-24)）*2^127. 阶码为 x 尾码为 y 的表示范围：[ ± 2^(-y) * 2^
( -2^(x-1) ), ± ( 1- 2^(-(y+1)) ) *2^(2^(x-1)-1)]

问：计算思维归根结底是人的思维，还是计算机的思维？
解答：计算思维归根结底还是人的思维，而不是计算机的思维方式，是一种概念化思维，而
不是程序化思维，是数学和工程思维互补与融合的思维，不是纯数学性的思维，是面向所有
人的思维，不仅仅是计算机科学家的思维。在计算机科学领域中的计算思维，在很多情况下
是以“算法”的形式呈现的，因此，狭义地讲，计算思维就是算法思维。数学建模是算法设
计的重要基石，所有算法的描述和算法分析无疑离不开数学建模的基础。


问：在多分支选择结构中，判断条件的先后顺序对执行效率有影响吗？通常会将什么样的条件
写在前面先判断？
解答：有影响。通常会将发生的可能性较大的选项写在前面优先判断，这样有助于提高执行效率。

问：如何控制循环不会成为死循环？
解答：执行循环体时必须改变一个或多个变量的值，以保证在经过有限次重复后循环的控制条件
不再满足（即为假）。

问：如何输入两个异号数或者同号数？用什么样的循环结构能够确保用户从键盘输入的两个数
是异号数或者同号数？
解答：用直到型循环结构实现。

问：变量是一个“量”吗？
解答：不是量，我们是通过变量名来访问变量的值的。变量有 4 个属性：变量名，变量的值，变量的地址，变量的类型。

问：结构化程序设计的核心是什么？在面向对象程序设计方法出现以后，学习结构化程序设计方法是否还有意义？
解答：结构化程序设计的核心是要求程序只由顺序、选择和循环三种基本控制结构组成，采用自顶向下，逐步求精的程序设计方法。
面向对象的程序设计方法中也包含了结构化程序设计的思想，在设计类中的方法时也需要采用结构化程序设计的思想。

问：高内聚、低耦合的系统究竟有什么好处？
解答：从短期来看，好处并不明显，甚至会影响系统的开发进度，因为高内聚、低耦合对系
统开发设计人员提出了更高的要求。它的好处主要体现在系统持续更新和维护的过程中，高
内聚、低耦合的系统具有更好的可重用性、可维护性，以及可扩展性。

问：模块化设计方法与逐步求精方法有何联系和区别？
解答：对一些规模较大的程序进行逐步求精时，为使程序结构更清晰，常采用分而治之
的策略，用过程、函数或子程序表示一些功能相对独立的部分，从而使一个比较大的程序分
解成若干个功能独立的小的程序段，这种分段结构形式就蕴含着模块化设计思想。而对每个
模块而言，又可采用逐步求精方法进行程序设计。
此外，模块化程序设计不一定是自顶向下的，也可以是自底向上的，但自顶向下设计必
须遵循模块化设计的要求，从这个意义上说，自顶向下、逐步求精也包含了模块化设计的思
想。
模块化设计方法与逐步求精方法的区别在于：一方面，就程序规模而言，逐步求精主要
指一个程序的设计过程，而模块化设计主要指一个比较大的软件系统的设计过程。另一方面，
就程序设计的两种方法而言，逐步求精方法侧重于分解，而模块化设计侧重于抽象。

问：在生活中，还有哪些可以用递推法求解的例子？
解答：银行利息等。

问：直接迭代法存在的主要问题是什么？
解答：需要选择合适的迭代初值和迭代公式,否则容易造成迭代过程不收敛。

问：在生活中，还有哪些可以用迭代法求解的例子
解答：欧几里德算法，用于计算两个整数 a,b 的最大公约数。

问：结合第一周介绍的浮点数，请你说明在程序设计中如何判断一个浮点数是否为 0？
解答：浮点数不能在计算机中精确表示，因此不能直接与 0 比较，只能比较是否近似为 0，即比
较近似相等。根据实际情况事先定义要求的解的精确度ε ，如取ε =1*10-6，如果|x|< ε 成立, 可认
为浮点数 x 近似为 0

问：如果已知一组数据的范围在 0 到 100 之间，那么能否将最大值的初值设为-1？与选择这组数据中的第一个数据作为初值相比，哪种算法更好？
解答：已知一组数据的范围在 0 到 100 之间时，可以将最大值的初值设为-1。但这种方法不具备
普遍性，因为当这组数据都变成负值的时候，这种方法就不再适用了。
选择这组数据中的第一个数据作为初值，这种方法更好，与这组数据的取值范围无关，无
论何种情况，总可以正确计算出最大值。


5.3 常用的算法——查找算法（线性查找）——循规蹈矩
线性查找
问：
（1）对 1024 个元素进行线性查找，平均情况下需要几次比较？
.解答：512 次
（2）我们生活中的哪些问题实际上是使用了线性查找的方法？
解答：在一叠光盘里找到自己想要的光盘。在箱子里找到自己想要的衣服。。。。。
 5.4 常用的算法——查找算法（二分查找）——看商品猜价格的秘诀
问：
（1）对 1024 个元素进行二分查找，最多需要几次比较？
解答：10 次.
（2）我们生活中的哪些问题实际上是使用了（或者说可以使用）二分查找（即对分搜索）的方
法？
解答：工人维修一条 10km 长的电话线，沿途大约有 200 多根电线杆，采用二分法，每查一次，
就可以把待查线路长度缩减为一半，迅速查出故障所在。
 5.5 常用的算法——查找算法（分块查找）——图书馆查书的奥秘
问：
（1）索引表在分块查找算法中起的作用是什么？你能举出生活中需要分块查找的例子吗？
解答：用于快速确定要查找的数所在的块。
（2）我们生活中的哪些问题实际上是使用了（或者说可以使用）分块查找的方法？
解答：除了在图书馆查书以外，比如要查找一个人的户口本，先确定他在哪个派出所，然后再在
这个派出所管辖的范围内查找他的户口本。再如查字典，先找到这个字的偏旁部首所在的页码范
围，然后再到这个页码范围内去找这个字。
 5.6 常用的算法——查找算法（哈希查找）——小哈希映射大道理
问：
（1）为什么说哈希查找是最能体现计算机科学精髓的查找方法？
解答：哈希查找是利用哈希函数由记录的关键字值直接计算出该记录的地址，是从 关键字到地址
的直接转换，无需反复比较，其核心不在于如何“比较”，而在于如何“计算”，哈希查找是最能
体现计算机科学精髓的查找方法。
（2）你还知道哪些常见的构造哈希函数的方法？
解答：直接定址法，数字分析法，折叠法，平方取中法，伪随机数法，除留余数法等。
（3）你认为什么样的问题或者应用场合适合用哈希查找算法？
解答：数据量比较大且无序排列。

6.1 冒泡排序如何进行优化？
问：我们在这节内容中讲解了冒泡排序法，但并没有讲解这个算法如何优化。而事实上由于数
据的不同，我们是可以进行不同程度上的优化。大家可以想想在什么数据上可以做哪些有技巧
性的优化？最好能给出你设想的数据和优化方法
答：在排序时加入逻辑变量，检查数据是否有交换，若没有交换发生，说明已经数据已经排好序
了













