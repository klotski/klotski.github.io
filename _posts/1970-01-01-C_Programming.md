---
layout: default
title: C语言程序设计
category: MOOC
---

教材：[《C语言程序设计（第3版）》](https://detail.tmall.com/item.htm?spm=a220m.1000862.1000725.1.EAdHGP&id=522555242559&is_b=1&cat_id=2&q=%BA%CE%C7%D5%C3%FA&rn=d104b2ad24867586c44f0d7a3b2dbbdf)
配套实验教材：[《C语言程序设计实验与习题指导(第3版)》](https://detail.tmall.com/item.htm?spm=a220o.1000855.1998025129.1.PetoDi&id=522558608654&pvid=91f7f52d-4396-4675-914c-8410257c2ebb&abbucket=_AB-M32_B17&acm=03054.1003.1.971095&aldid=P9WCWMMC&abtest=_AB-LR32-PR32&scm=1007.12559.40794.100200300000000&pos=1)
IDE：[Dev-C++](http://sourceforge.net/projects/orwelldevcpp/?source=directory)
练习平台：[PTA](https://pta.patest.cn/ "Programming Teaching Assistant")
认证平台：[PAT](https://www.patest.cn/ "Programming Ability Test")

---

[TOC]

**计算机的思维**

- 枚举
- 二分搜索

**程序的执行**
解释：比较灵活、可移植性高
编译：执行效率较高，有确定的运算性能



C语⾔
• C语⾔是从B语⾔发展⽽来的，B语⾔是从BCPL发展⽽来的，BCPL是从 FORTRAN发展⽽来的
• BCPL和B都⽀持指针间接⽅式，所以C也⽀持了
• C语⾔还受到了PL/1的影响，还和PDP-11的机器语⾔有很⼤的关系
• 1973年3⽉，第三版的Unix上出现了C语⾔的编译器
• 1973年11⽉，第四版的Unix（System Four）发布了，这个版本是完全⽤C语⾔重新写的

C的发展与版本-标准
• 1989年ANSI发布了⼀个标准——ANSI C
• 1990年ISO接受了ANSI的标准——C89
• C的标准在1995年和1999年两次更新——C95和C99
• 所有的当代编译器都⽀持C99了

Windows: MS Visual Studio Express
osX: Xcode
• vim（和MinGW⼀起）


• 如果你在使⽤Dev C++ 4.9.9.2
• system("pause");
• 让程序运⾏完成后，窗⼝还能留下
• 不是Dev C++ 4.9.9.2就不需要这个了

**标识（zhì）符**

- 只能由字母、数字和下划线组成，其中第一个字符必须是字母或下划线
- 关键字（保留字）[^footnote2]不可以⽤做标识符
- main, include, define, bool 不是关键字
- 英文字母的大小写形式是有区别的

## 变量

> 虽然C语⾔并没有强制要求所有的变量都在定义的地⽅做初始化，但是所有的变量在 第⼀次被使⽤（出现在赋值运算符的右边）之前被应该赋值⼀次。

本地变量/局部变量未初始化时，值是不确定的。

全局变量具有全局的⽣存期和作⽤域

全局变量初始化
• 没有做初始化的全局变量会得到0值
• 指针会得到NULL值
• 只能⽤编译时刻已知的值来初始化全局变量
• 它们的初始化发⽣在main函数之前

被隐藏的全局变量
• 如果函数内部存在与全局变量同名的变量，则全局变量被隐藏

静态本地变量
• 在本地变量定义时加上static修饰符就成为静态本地变量
• 当函数离开的时候，静态本地变量会继续存在并保持其值
• 静态本地变量的初始化只会在第⼀次进⼊这个函数时做，以后进⼊函数时会保持上次离开时的值

静态本地变量实际上是特殊的全局变量
• 它们位于相同的内存区域
• 静态本地变量具有全局的⽣存期，函数内的局部作⽤域
• static在这⾥的意思是局部作⽤域（本地可访问）

|术语|定义|举例|
|----|----|----|
|常量|||
|变量|||
|字面量|||
|直接量|||

> 固定不变的数，是常数。直接写在程序⾥，我们称作直接量（literal）。
100这个固定不变的数，叫做常数。直接
写在程序⾥，我们称作直接量（literal，
字⾯量）。

|ANSI C|C99|
|------|---|
|只能在代码开头的地方定义变量|在变量第一次被使用前定义即可|
||const(C中这代表不变的变量，在C++中是常量)，名称一般大写，初始化后就不能再赋值了`const int AMOUNT = 100;`|


> C是⼀种有类型的语⾔，所有的变量在使⽤之前必须定义或声明，所有的变量必须具有确定的数据类型。数据类型表⽰在变量中可以存放什么样的数据，变量中只能存放指定类型的数据，程序运⾏过程中也不能改变变量的类型。



两个整数的运算的结果只能是整数
• 10/3*3=>?
小数部分无论大小一律舍弃，不会做四舍五入
当浮点数和整数放到⼀起运算时，C会将整数转换成浮点数，然后进⾏浮点数的运算

10.0/3*3 = 10.000000
为什么不是9.999999？

• 整数
• int
• printf("%d",…)
• scanf("%d",…)
• 带⼩数点的数
• double
• printf("%f",…)
• scanf("%lf",…)

**赋值运算**
赋值也是运算，也有结果
• a=6的结果是a被赋予的值，也就是6
• a=b=6 —> a=(b=6)



**递增递减运算符**
a++的值是a加1以前的值，⽽++a的值是加了1以后的值，⽆论哪个，a⾃⼰的值都加了1了。
|表达式|运算 |表达式的值|
|:----:|:--:|:--------:|
|count++|给count加1|count原来的值|
|++count|给count加1|count+1以后的值|
|count--|给count减1|count原来的值|
|--count|给count减1|count-1以后的值|

所有的关系运算符的优先级比算术运算的低，但是比赋值运算的高
== 和 != 的优先级比其他的低，而连续的关系运算是从左到右进行的

Warning 也应解决！

**switch-case**

```c
switch ( 控制表达式 ) {
case 常量:
	 	 语句
	 	 ……
case 常量:
	 	 语句
	 	 ……
default:
	 	 语句
	 	 ……
}
```

- 控制表达式只能是整数型的结果
- 常量可以是常数，也可以是常数计算的表达式
- 根据表达式的结果，寻找匹配的case，并执⾏case后⾯的语句，⼀直到break为⽌
- 如果所有的case都不匹配，那么就执⾏default后⾯的语句；如果没有default，那就什么都不做

switch语句可以看作是⼀种基于计算的跳转，计算控制表达式的值后，程序会 跳转到相匹配的case（分⽀标号）处。分⽀标号只是说明switch内部位置的路标，在执⾏完分⽀中的最后⼀条语句后，如果后⾯没有break，就会顺序执⾏到下⾯的case⾥去，直到遇到⼀个break，或者switch结束为⽌。

**for循环**
for中的每⼀个表达式都是可以省略的
for (; 条件; ) == while ( 条件 )

**Tips for loops**
• 如果有固定次数，⽤for
• 如果必须执⾏⼀次，⽤do_while
• 其他情况⽤while

**break vs continue**
break: 跳出循环
continue: 跳过循环这⼀轮剩下的语句进⼊
下⼀轮
break和continue只能对它所在的那层循环做


**函数原型**
函数头，以分号`;`结尾，就构成了函数的原型。

- 函数原型的目的是告诉编译器这个函数⻓什么样
    - 名称
    - 参数（数量及类型）
    - 返回类型
- 旧标准习惯把函数原型写在调⽤它的函数⾥⾯，现在⼀般写在调⽤它的函数前⾯
- 原型⾥可以不写参数的名字，但是⼀般仍然写上

**参数传递**
- 调⽤函数时给的值与参数的类型不匹配是C语⾔传统上最⼤的漏洞。编译器总是悄悄替你把类型转换好，但是这很可能不是你所期望的。
- C语⾔在调⽤函数时，永远只能传值给函数。

**本地变量的规则**
- 本地变量是定义在块内的
    - 它可以是定义在函数的块内
    - 也可以定义在语句的块内
    - 甚⾄可以随便拉⼀对⼤括号来定义变量
- 程序运⾏进⼊这个块之前，其中的变量不存在，离开这个块，其中的变量就消失了
- 块外⾯定义的变量在⾥⾯仍然有效
- 块⾥⾯定义了和外⾯同名的变量则掩盖了外⾯的
- 不能在⼀个块内定义同名的变量
- 本地变量不会被默认初始化
- 参数在进⼊函数的时候被初始化了


**数组**

- C99之前：元素数量必须是编译时刻确定的字⾯量
- 其中所有的元素具有相同的数据类型；
- ⼀旦创建，不能改变⼤⼩
- 数组中的元素在内存中是连续依次排列的

**有效的下标范围**

- 编译器和运⾏环境都不会检查数组下标是否越界，⽆论是对数组单元做读还是写
- ⼀旦程序运⾏，越界的数组访问可能造成问题，导致程序崩溃 segmentation fault，但是也可能运⽓好，没造成严重的后果
- 程序员来保证程序只使⽤有效的下标值：[0,数组的⼤⼩－1]


**数组的集成初始化**

- 如果给出了数组的⼤⼩，但是后⾯的初始值数量不⾜，则其后的元素被初始化为0

**集成初始化时的定位**

- ⽤[n]在初始化数据中给出定位
- 没有定位的数据接在前⾯的位置后⾯
- 其他位置的值补零
- 也可以不给出数组⼤⼩，让编译器算
- 特别适合初始数据稀疏的数组


**数组的⼤⼩**

- sizeof给出整个数组所占据的内容的⼤⼩，单位是字节
- sizeof(a[0])给出数组中单个元素的⼤⼩，于是相除就得到了数组的单元个数 `sizeof(a)/sizeof(a[0])`

**数组的赋值**

- 数组变量本⾝不能被赋值
- 要把⼀个数组的所有元素交给另⼀个数组，必须采⽤遍历
```c
for (i = 1; i < length; i++) {
    b[i] = a[i];
}
```

- 数组作为函数参数时，往往必须再⽤另⼀个参数来传⼊数组的⼤⼩
- 不能在[]中给出数组的⼤⼩
- 不能再利⽤sizeof来计算数组的元素个数

**⼆维数组的初始化**

- 列数是必须给出的，⾏数可以由编译器来数
- 每⾏⼀个{}，逗号分隔
- 最后的逗号可以存在，有古⽼的传统
- 如果省略，表⽰补零
- 也可以⽤定位（＊C99 ONLY）

**指针**

& 取地址运算符。取得变量的地址，操作数必须是变量。
%p 地址的大小(sizeof(&i))是否与int相同取决于编译器

**指针应⽤场景**

- 交换两个变量的值
- 函数返回多个值，某些值就只能通过指针返回，传⼊的参数实际上是需要保存带回的结果的变量
- 函数返回运算的状态，结果通过指针返回

传⼊函数的数组成了什么？
函数参数表中的数组实际上是指针，但是可以⽤数组的运算符[]进⾏运算

**数组变量是特殊的指针**

- 数组变量本⾝表达地址，所以
    - int a[10]; int*p=a; // ⽆需⽤&取地址
- 但是数组的单元表达的是变量，需要⽤&取地址
    - a == &a[0]
- []运算符可以对数组做，也可以对指针做：
    - p[0] <==> a[0]
- *运算符可以对指针做，也可以对数组做：
    - *a = 25;
- 数组变量是const的指针，所以不能被赋值
    - int a[] <==> int * const a=….

数组变量可以*被看作*是const的指针变量。

- 指针是const，表⽰⼀旦得到了某个变量的地址，不能再指向其他变量
    - int * const q = &i; // q 是 const
    - *q = 26; // OK
    - q++; // ERROR
- 所指是const，表⽰不能通过这个指针去修改那个变量（并不能使得那个变量成为const）
    - const int *p = &i;
    - *p = 26; // ERROR! (*p) 是 const
    - i = 26; //OK
    - p = &j; //OK

**指针运算**

- 给指针加、减⼀个整数(+, +=, -, -=)
- 递增递减(++/—)
- 两个指针相减

*p++
- 取出p所指的那个数据，之后把p移到下⼀个位置去
- 的优先级虽然⾼，但是没有++⾼
- 常⽤于数组类的连续空间操作
- 在某些CPU上，这可以直接被翻译成⼀条汇编指令

**指针比较**

- <, <=, ==, >, >=, != 都可以对指针做
- ⽐较它们在内存中的地址
- 数组中的单元的地址肯定是线性递增的

**0地址**

- 当然你的内存（虚拟内存）中有0地址，但是0地址通常是个不能随便碰的地址
- 可以⽤0地址来表⽰特殊的事情：
    - 返回的指针是⽆效的
    - 指针没有被真正初始化（先初始化为0）
- NULL是⼀个预定定义的符号，表⽰0地址
    - 有的编译器不愿意你⽤0来表⽰0地址

**指针的类型**

- ⽆论指向什么类型，所有的指针的⼤⼩都是⼀样的，因为都是地址
- 但是指向不同类型的指针是不能直接互相赋值的，这是为了避免⽤错指针

**指针的类型转换**

- void* 表⽰不知道指向什么东⻄的指针，计算时与char*相同（但不相通）
- 指针也可以转换类型，int *p = &i; void*q = (void*)p; 这并没有改变p所指的变量的类型，⽽是让后⼈⽤不同的眼光通过p看它所指的变量（我不再当你是int啦，我认为你就是个void!）

**⽤指针来做什么**
• 需要传⼊较⼤的数据时⽤作参数
• 传⼊数组后对数组做操作
• 函数返回不⽌⼀个结果
• 需要⽤函数来修改不⽌⼀个变量
• 动态申请的内存..


**动态内存分配**

如果输⼊数据时，先告诉个数，然后再输⼊，要记录每个数据

- C99：⽤变量做数组定义的⼤⼩
- C99之前：int *a = (int*)malloc(n*sizeof(int));

**malloc**
`#include <stdlib.h>`
void* malloc(size_t size);
• 向malloc申请的空间的⼤⼩是以字节为单位的
• 返回的结果是void*，需要类型转换为⾃⼰需要的类型
• (int*)malloc(n*sizeof(int))

没空间了？
如果申请失败则返回0，或者叫做NULL

free()

**函数间传递指针**

如果程序中要⽤到动态分配的内存，并且会在函数之间传递，好的模式是在同⼀个地⽅malloc和free，让调⽤者⾃⼰申请，传地址进函数，函数再返回这个地址出来。

**函数返回指针或数组？**

只能返回
- 传⼊的参数：实际就是在调⽤者那⾥
- 全局变量或动态分配的内存

##字符串##

字符数组`char word[] = {‘H’, ‘e’, ‘l’, ‘l’, ‘o’,‘!’};`
字符串`char word[] = {‘H’, ‘e’, ‘l’, ‘l’, ‘o’,‘!’,’\0’};`
字符串变量`char *str = “Hello”;` `char word[] = “Hello”;`

- 以0（整数0）结尾的⼀串字符（0或’\0’是⼀样的，但是和’0’不同）
- 字符串以以字符数组的形式存在，以数组或指针的形式访问（更多的是以指针的形式）
- string.h ⾥有很多处理字符串的函数
- 字符串字⾯量可以⽤来初始化字符数组

- 两个相邻的字符串常量会被⾃动连接起来
- ⾏末的\表⽰下⼀⾏还是这个字符串常量

char* s = "Hello, world!";
- s 是⼀个指针，初始化为指向⼀个字符串常量
    - 实际上s是 const char* s ，但是由于历史的原因，编译器接受不带const的写法
    - 试图对s所指的字符串做写⼊会导致严重的后果
- 如果需要修改字符串，应该⽤数组：`char s[] = "Hello, world!";`

指针还是数组？
char *str = “Hello”;
- 指针：这个字符串不知道在哪⾥
- 处理参数
- 动态分配空间
- 如果要处理⼀个字符串—>指针
char word[] = “Hello”;
- 数组：这个字符串在这⾥
- 作为本地变量空间⾃动被回收
- 如果要构造⼀个字符串—>数组


## 枚举

- 枚举是⼀种⽤户定义的数据类型，⽤关键字 enum 声明：`enum 枚举类型名字 {名字0, …, 名字n} ;`
- 枚举量可以作为值，类型是int（以整数来做内部计算和外部输⼊输出），值依次从0到n。
- 声明枚举量的时候可以指定值 `enum COLOR { RED=1, YELLOW, GREEN = 5};`
- 虽然枚举类型可以当作类型使⽤，但是实际上很少⽤，不好用
- 即使给枚举类型的变量赋不存在的整数值也没有任何warning或error
- 如果有意义上排⽐的名字，⽤枚举⽐const int⽅便
- 枚举⽐宏（macro）好，因为枚举有int类型

Tip: 
> 套路：⾃动计数的枚举 
> `enum COLOR {RED, YELLOW, GREEN, NumCOLORS};`
> 这样需要遍历所有的枚举量或者需要建⽴⼀个⽤枚举量做下标的数组的时候就很⽅便了

## 结构类型

> “If a large structure is to be passed to a function, it is generally more efficient to pass a pointer than to copy the whole structure” K&R (P.131)

- 内存对齐

## 联合

- 存储
    - 所有的成员共享⼀个空间
    - 同⼀时间只有⼀个成员是有效的
    - union的⼤⼩是其最⼤的成员
- 初始化
    - 对第⼀个成员做初始化

## 宏

`#define MIN(a,b) ((a)>(b)?(b):(a))` 
`#define TOUPPER(c) ('a'<=(c)&&(c)<='z'?(c)-'a'+'A':(c))`

 #define <名字> <值>
• 注意没有结尾的分号，因为不是C的语句
• 名字必须是⼀个单词，值可以是各种东⻄
• 在C语⾔的编译器开始编译之前，编译预处理程序
（cpp）会把程序中的名字换成值
• 完全的⽂本替换
• gcc —save-temps

`#define _DEBUG`
• 这类宏是⽤于条件编译的，后⾯有其他的编译预处理
指令来检查这个宏是否已经被定义过了

预定义的宏
• __LINE__
• __FILE__
• __DATE__
• __TIME__
• __STDC__

__STDC__是预定义宏。当它被定义后，编译器将按照ansic标准来编译你的c程序。
ANSIC标准定义了以下6种可供C语言使用的预定义宏：   
      __LINE__                       在源代码中插入当前源代码行号   
      __FILE__                       在源代码中插入当前源代码文件名   
      __DATE__                       在源代码中插入当前编译日期〔注意和当前系统日期区别开来〕   
      __TIME__                       在源代码中插入当前编译时间〔注意和当前系统时间区别开来〕         
      __STDC__                       当要求程序严格遵循ANSIC标准时该标识符被赋值为1。   
      __cplusplus   
  标识符__LINE__和__FILE__通常用来调试程序；   
  标识符__DATE__和__TIME__通常用来在编译后的程序中加入一个时间标志，以区分程序的不同版本；   
  当要求程序严格遵循ANSIC标准时，标识符__STDC__就会被赋值为1；   
  当用C++编译程序编译时，标识符__cplusplus就会被定义

带参数的宏
- 整个值要括号
- 参数出现的每个地⽅都要括号


`#include`有两种形式来指出要插⼊的⽂件
- ""要求编译器⾸先在当前目录（.c⽂件所在的目录）寻找这个⽂件，如果没有，到编译器指定的目录去找
- <>让编译器只在指定的目录去找

不对外公开的函数
- 在函数前⾯加上static就使得它成为只能在所在的编译单元中被使⽤的函数
- 在全局变量前⾯加上static就使得它成为只能在所在的编译单元中被使⽤的全局变量


变量的声明
- int i;是变量的定义
- extern int i;是变量的声明

声明是不产⽣代码的东⻄
• 函数原型
• 变量声明
• 结构声明
• 宏声明
• 枚举声明
• 类型声明
• inline函数
定义是产⽣代码的东⻄

标准头⽂件结构
• 运⽤条件编译和宏，保证这个头⽂件在⼀个编译单元中只会被#include⼀次
• #pragma once也能起到相同的作⽤，但是不是所有的编译器都⽀持

```c
#ifndef __LIST_HEAD__
#define __LIST_HEAD__

#include "node.h"

typedef struct _list {
    Node* head;
    Node* tail;
} List;

#endif
```

## 位运算
|位运算|解释|应用|
|------|----|----|
| & 按位与|如果 (x)<sub>i</sub> == 1 并且 (y)<sub>i</sub> == 1，那么 (x & y)<sub>i</sub> = 1 <br> 否则(x & y)<sub>i</sub> = 0|让某⼀位或某些位为0：x & 0xFE <br> 取⼀个数中的⼀段：x & 0xFF|
| \| 按位或|如果 (x)<sub>i</sub> == 1 或 (y)<sub>i</sub> == 1，那么 (x \| y)<sub>i</sub> = 1 <br> 否则 (x \| y)<sub>i</sub> == 0|使得⼀位或⼏个位为1：x \| 0x01 <br> 把两个数拼起来：0x00FF \| 0xFF00|
| ~ 按位取反|(~x)<sub>i</sub> = 1 - (x)<sub>i</sub> <br> 把1位变0，0位变1|想得到全部位为1的数：~0 <br> 7的⼆进制是0111，x \| 7使得低3位为1，⽽ <br> x & ~7，就使得低3位为0|
| ^ 按位异或|如果(x)<sub>i</sub>== (y)<sub>i</sub>，那么(x ^ y)<sub>i</sub> = 0 <br> 否则的话，(x ^ y)<sub>i</sub> == 1 <br> 如果两个位相等，那么结果为0；不相等，结果为1|如果x和y相等，那么x ^ y的结果为0 <br> 对⼀个变量⽤同⼀个值异或两次，等于什么也没做 x ^ y ^ y —> x|
| << 左移|i << j <br> i中所有的位向左移动j个位置，⽽右边填⼊0 <br> 所有⼩于int的类型，移位以int的⽅式来做，结果是int|x <<= 1 等价于 x *= 2 <br> x <<= n 等价于 x *= 2<sup>n</sup>|
| \>> 右移|i >> j <br> i中所有的位向右移j位 <br> 所有⼩于int的类型，移位以int的⽅式来做，结果是int <br> 对于unsigned的类型，左边填⼊0 <br> 对于signed的类型，左边填⼊原来的最⾼位（保持符号不变）|x >>= 1 等价于 x /= 2 <br> x >>= n 等价于 x /= 2n|

## 位段

把⼀个int的若干位组合成⼀个结构
```c
struct {
    unsigned int leading : 3;
    unsigned int FLAG1: 1;
    unsigned int FLAG2: 1;
    int trailing: 11;
};
```

- 可以直接⽤位段的成员名称来访问
- ⽐移位、与、或还⽅便
- 编译器会安排其中的位的排列，不具有可移植性
- 当所需的位超过⼀个int时会采⽤多个int

%hhx
(char)~c
(char)-c




# 读书笔记
## 第一章 引言

> 计算机程序是人们为解决某种问题用计算机可以识别的代码编排的一系列加工步骤。

<p></p>

> 算法是一组明确的解决问题的步骤，它产生结果并可在有限的时间内终止。

<p></p>

> 所有的 C 程序都有且只有一个 main( ) 函数。C 程序从 main( ) 函数处开始运行，当 main( ) 函数结束时，程序也就结束了。

<p></p>

> 变量名代表内存中的一个存储单元，用于存放该变量的值，而该存储单元的大小由变量的类型决定。例如在Visual C++中，整数变量占用 4 个字节的空间。因此，每个整数都有一定的取值范围。

<p></p>

**冯·诺依曼（John Von Neumann）理论要点**

- 计算机硬件设备由存储器、运算器、控制器、输入设备和输出设备五部分组成。
- 存储程序思想——把计算过程描述为由许多命令按一定顺序组成的程序，然后把程序和数据一起输入计算机，计算机对已存入的程序和数据处理后，输出结果。

**程序设计语言的功能**

- 数据表达
    - 基本数据类型
    - 构造类型
- 流程控制（数据处理）
    - 语句级控制[^footnote]：分支控制、循环控制
    - 单位级控制：函数定义与调用

**数据类型涉及两方面的内容**

- 该数据类型代表的数据是什么（数据类型的定义域）
- 能在这些数据上做什么（即操作，或称运算）

**描述算法的方式**

- 自然语言
- 伪代码
- 流程图

**问题求解过程**

1. 问题分析与算法设计
2. 编辑程序
3. 编译
4. 运行与调试

**调试方法**

- 设置断点并观察变量
- 单步跟踪

## 第二章

int main (void) 中的关键字 void 表示 main() 函数不需要参数。

`return 0;`结束 main() 的运行，并向系统返回一个整数 0，作为程序的结束状态。
按照惯例，返回 0 说明程序运行正常，返回其他数字则用于表示各种不同的错误情况。


> 在程序执行过程中，其值不能改变的量称为常量。常量可以直接用一个数来表示，称为直接常量（或称为常数），也可以用一个符号来表示，称为符号常量。常量只能赋值一次。变量，是指没有固定的值，可以改变的量，能多次赋值。

<p></p>

> 变量名代表内存中的一个存储单元，用于存放该变量的值，而该存储单元的大小由变量的类型决定。


**使用算术运算符时要注意：**

- 对两个整型数据作除法运算，结果是整数。
- 求余运算符取整型数据相除的余数，不能用于实型数据的运算。
- `+`和`-`还可以作为单目运算符，用于表示数值常量的符号。
- 双目运算符两侧操作数的类型要相同，否则，系统自动进行类型转换，使它们具有相同的类型，然后再运算。
关于类型转换的详细说明见6.3节。

**赋值运算类型转换**
在赋值运算时，如果赋值运算符两侧的数据类型不同，系统首先将赋值运算符右侧表达式的类型自动转换成赋值运算符左侧变量的类型，再给变量赋值。
详见6.3节。


**printf() 格式控制说明**
%d -> int
%f -> float, double，以小数形式输出浮点型数据（保留 6 位小数）

输出格式控制说明中，可以加宽度限定词，指定数据的输出宽度。
%md 指定了数据的输出宽度为 m (包括符号位)。若数据的实际位数（含符号位）小于 m，则左端补空格；若大于 m，则按实际位数输出。

%m.nf 指定了输出浮点型数据时保留 n 位小数，且输出宽度是 m（包括符号位和小数点）。若数据的实际位数小于 m，左端补空格；若大于 m，按实际位数输出。

**scanf() 格式控制说明**
int -> %d
float -> %f
double -> %lf

sum 用于保存累加和，初值应置为 0.
product 用于保存乘积，初值应置为 1.

> 当 n 较大（n>12）时，就无数用整数正确表示n!,所以把product 定义成浮点型变量，并在输出时通过 %.0f指定不要小数部分。

x % n 的结果是[0, n-1]的⼀个整数

整数的分解
⼀个整数是由1⾄多位数字组成的，如何分解出整数
的各个位上的数字，然后加以计算
• 对⼀个整数做%10的操作，就得到它的个位数；
• 对⼀个整数做/10的操作，就去掉了它的个位数；
• 然后再对2的结果做%10，就得到原来数的⼗位数了；
• 依此类推。

计算机中不能用浮点数来做精准的计算，因为浮点数不能准确地表达小数，如果用浮点数来计算，误差会一直累积。可以用整数来计算，比如用123分来表示1.23元。或者可以用BCD码。

**大小写转换**
• ‘a’-‘A’可以得到两段之间的距离，于是
- 大写转小写 a + 'a' - 'A'
- 小写转大写 a + 'A' - 'a'

如何判断⼀个字符c是否是⼤写字⺟？
• c >= ‘A’ && c<= ‘Z’

**C是有类型的语⾔**

- C语⾔的变量，必须：
    - 在使⽤前定义，并且
    - 确定类型
- C以后的语⾔向两个⽅向发展：
    - C++/Java更强调类型，对类型的检查更严格
    - JavaScript、Python、PHP不看重类型，甚⾄不需要事先定义

**类型安全**

- ⽀持强类型的观点认为明确的类型有助于尽早发现程序中的简单错误
- 反对强类型的观点认为过于强调类型迫使程序员⾯对底层、实现⽽⾮事务逻辑
- 总的来说，早期语⾔强调类型，⾯向底层的语⾔强调类型
- C语⾔需要类型，但是对类型的安全检查并不⾜够

**sizeof**
- 是⼀个运算符，给出某个类型或变量在内存中所占据的字节数
    - sizeof(int)
    - sizeof(i)
- 是静态运算符，它的结果在编译时刻就决定了
- 不要在sizeof的括号⾥做运算，这些运算不会做的

整数
• char：1字节（8⽐特）
• short：2字节
• int：取决于编译器（CPU），通常的意义是“1个字”
• long：取决于编译器（CPU），通常的意义是“1个字”
• long long：8字节

unsigned
• 如果⼀个字⾯量常数想要表达⾃⼰是unsigned，可以
在后⾯加u或U
• 255U
• ⽤l或L表⽰long(long)
• *unsigned的初衷并⾮扩展数能表达的范围，⽽是为了做纯⼆进制运算，主要是为了移位


**整数的输⼊输出**
只有两种形式：int或long long
• %d：int
• %u：unsigned
• %ld：long long
• %lu：unsigned long long


**8进制和16进制**
• ⼀个以0开始的数字字⾯量是8进制
• ⼀个以0x开始的数字字⾯量是16进制
• %o⽤于8进制，%x⽤于16进制
• 8进制和16进制只是如何把数字表达为字符串，与内部如何表达数字⽆关

**选择整数类型**

- 为什么整数要有那么多种？
    - 为了准确表达内存，做底层程序的需要
- 没有特殊需要，就选择int
    - 现在的CPU的字⻓普遍是32位或64位，⼀次内存读写就是⼀个int，⼀次计算也是⼀个int，选择更短的类型不会更快，甚⾄可能更慢
    - ＊现代的编译器⼀般会设计内存对⻬，所以更短的类型实际在内存中有可能也占据⼀个int的⼤⼩（虽然sizeof告诉你更⼩）
- unsigned与否只是输出的不同，内部计算是⼀样的

浮点的输⼊输出
类型 scanf printf
float %f %f, %e
double %lf %f,%e

printf和scanf⾥⽤%c来输⼊输出字符

超过范围的浮点数
• printf输出inf表⽰超过范围的浮点数：±∞
• printf输出nan表⽰不存在的浮点数

**浮点运算的精度**

- 带⼩数点的字⾯量是double⽽⾮float
- float需要⽤f或F后缀来表明⾝份

• f1 == f2可能失败
• fabs(f1-f2) < 1e-12

**选择浮点类型**
• 如果没有特殊需要，只使⽤double
• 现代CPU能直接对double做硬件运算，性能不会⽐float差，在64位的机器上，数据存储的速度也不⽐float慢

**逃逸字符**
字符 意义 字符 意义
\b 回退⼀格 \" 双引号
\t 到下⼀个表格位 \' 单引号
\n 换⾏ \\ 反斜杠本⾝
\r 回⻋

**逻辑类型**
• #include <stdbool.h>
• 之后就可以使⽤bool和true、false
bool实际上还是以int的⼿段实现的，所以可以当作int来计算
• 也只能当作int来输⼊输出


**类型转换**
⾃动类型转换
• 当运算符的两边出现不⼀致的类型时，会⾃动转换成
较⼤的类型
• ⼤的意思是能表达的数的范围更⼤
• char —> short —> int —> long —> long long
• int —> float —> double

• 对于printf，任何⼩于int的类型会被转换成int；float会
被转换成double
• 但是scanf不会，要输⼊short，需要%hd


强制类型转换
• 要把⼀个量强制转换成另⼀个类型（通常是较⼩的类
型），需要：(类型)值
• 注意这时候的安全性，⼩的变量不总能表达⼤的量
• (short)32768
• 只是从那个变量计算出了⼀个新的类型
的值，它并不改变那个变量，⽆论是值
还是类型都不改变


**逻辑运算**是⾃左向右进⾏的，如果左边的结果已经能够决定结果了，就不会做右边的计算
• 对于&&，左边是false时就不做右边了
• 对于||，左边是true时就不做右边了

**逗号运算符**
逗号⽤来连接两个表达式，并以其右边的表达式的值作为它的结果。
逗号的优先级是所有的运算符中最低的，所以它两边的表达式会先计算；逗号的组合关系是⾃左向右，所以左边的表达式会先计算，⽽右边的表达式的值就留下来作为逗号运算的结果。



------
# Operator
|优先级|运算符|结合关系|
|------|------|------|
|1|()|从左到右|
|2|！ + - ++ --|从右到左|
||||
条件运算符的优先级⾼于赋值运算符，但是低于其他运算符

# Data Types
|Type|Explanation|Format Specifier|
|----|-----------|----------------|

# Standard Library Functions
|Library|Function|Description|
|-------|--------|-----------|
||rand()|生成随机整数|

编程语言是命令性而非交谈性的语言

**求位数**

- 判断数的范围。如 $x\in[99,999]$，则 $x$ 为三位数。
- 通过%10去掉最右侧一位，循环计数。

**调试 (Debug)**

- 编写完成后一定要调试，用边界值等方法。
- ⼈脑模拟计算机的运行，在纸上列出所有的变量，随着程序的进展不断重新计算变量的值。
- 在程序适当的地方插入`printf`来输出变量的内容

变量->算法->流程图->程序




# Best Practice

计算过程中换算为只有整数，比如算时间差，可转换为分钟。
小时差 = 分钟/60
分钟差 = 分钟%60


**多项式加法**

```c
#include <stdio.h>

int main(void)
{
	int polynomial[101] = {0};

	int cnt = 0;
	for (int i = 0; cnt < 2; i++) {
		int pow, factor;
		scanf("%d %d", &pow, &factor);
		polynomial[pow] += factor;
		if (pow == 0) {
			cnt ++;
		}
	}
	
	int flag = 1;
	for (int i = 100; i > 0; i--) {
		if (polynomial[i] != 0) {
			if (polynomial[i] > 0 && flag == 0) {
				printf("+");
			}
			
			if (polynomial[i] == 1) {
				printf("x");
			} else if (polynomial[i] == -1) {
				printf("-x");
			} else {
				printf("%dx", polynomial[i]);
			}
			
			if (i != 1) {
				printf("%d", i);
			}
			
			flag = 0;
		}
	}
	
	if (flag) {
		printf("%d", 0);
	} else if (polynomial[0] != 0){
		printf("+%d", polynomial[0]);
	}
	
	return 0;
}
```

**正序分解整数**

```c
#include <stdio.h>

int main()
{
	int x;
	scanf("%d", &x);

	int mask = 1;
	int t = x;
	while (t > 9) {
		t /= 10;
		mask *= 10;
	} 
	printf("x=%d, mask=%d\n", x, mask);
	do {
		int d = x / mask;
		printf("%d", d);
		if ( mask > 9 ) {
			printf(" ");
		}
		x %= mask;
		mask /= 10;
	} while ( mask > 0 );
	printf("\n");

	return 0;
}
```

**枚举求最⼤公约数**
```c
/*
 *1. 设t为2；
 *2. 如果u和v都能被t整除，则记下这个t
 *3. t加1后重复第2步，直到t等于u或v；
 *4. 那么，曾经记下的最⼤的可以同时整除u和v的t就是gcd
 */
```

**辗转相除法求最大公约数 (Greatest Common Divisor)**
```c
/*
 *1. 如果 b 等于 0，计算结束，a 就是最⼤公约数；
 *2. 否则，计算 a 除以 b 的余数，让 a 等于 b，⽽ b 等于那个余数；
 *3. 回到第⼀步。
 */
#include <stdio.h>

int main(int argc, char const *argv[])
{
	int a,b;
	int t;
	
	scanf("%d %d", &a, &b);
	int origA = a;
	int origB = b;
	while (b != 0) {
		t = a % b;
		a = b;
		b = t;
	}
	printf("%d和%d的最大公约数是%d.\n", origA, origB, a);
	
	return 0;
}
```

**分解质因数**

```c
/*
 *读入一个[2,100000]范围内的整数，然后输出它的质因数分解式；当读到的就是素数时，输出它本身。
 *输入格式: 一个整数，范围在[2,100000]内。
 *输出格式：n=axbxcxd 或 n=n 所有的符号之间都没有空格，x是小写字母x。
 */

#include <stdio.h>

int isPrime(int n);

int main(void)
{
	int n;
	scanf("%d", &n);
	
	printf("%d=", n);
	while (isPrime(n) == 0) {
		int i;
		for (i = 2; i < n; i++) {
			if (n%i == 0) {
				printf("%dx", i);
				n = n/i;
				break;
			}
		} 
	}
	printf("%d", n);
	
    return 0;
}

int isPrime(int n)
{
	int ret = 1;
	int i;
	for (i = 2; i < n; i++) {
		if (n%i == 0) {
			ret = 0;
			break;
		}
	}
	return ret;
}
```

**投票统计**

```c
/*
 *输⼊数量不确定的[0,9]范围内的整数，统计每⼀种数字出现的次数，输⼊-1表⽰结束
 */

const int NUM = 10;
int x;
int count[NUM] = {0}；
int i;

scanf("%d", &x);
while (x != -1) {
    if (x >= 0 && x <= 9) {
        count[x]++;
    }
    scanf("%d", &x);
}

for (i = 0; i < NUM; i++) {
    printf("%d:%d\n", i, count[i]);
}
 
```

**交换两个变量的值**

```c
#include <stdio.h>

void swap(int *pa, int *pb);

int main(void)
{
    int a = 0;
    int b = 0;
    scanf("%d %d", &a, &b);
    printf("a=%d,b=%d\n", a, b);
    swap(&a, &b);
    printf("a=%d,b=%d\n", a, b);

    return 0;
}

void swap(int *pa, int *pb)
{
    int t = *pa;
    *pa = *pb;
    *pb = t;
}
```

**处理GPS数据**

```c
#include <stdio.h>
#include <string.h>
#include <math.h>

int checksum(char *p);
char located(char *p);
void utc_bjt(int utc_h, int m, int s);

int main(int argc, char const *argv[])
{
	char a[1000] = "";
	char gprmc[] = "$GPRMC";
	char end[] = "END";
	int utc_h = 0;
	int m = 0;
	int s = 0;
	
	do {
		scanf("%s", a);
		if (strstr(a, gprmc)) {
			if (checksum(a) && located(a) == 'A') {
				char *utc = strchr(a, ',') +1;
				utc_h = (*utc - 48)*10 + (*(utc+1) - 48);
				m = (*(utc+2) - 48)*10 + (*(utc+3) - 48);
				s = (*(utc+4) - 48)*10 + (*(utc+5) - 48);
			}
		}
	} while (strcmp(a, end) != 0);

	utc_bjt(utc_h, m, s);
    
	return 0;
}

/*
 * compare the xor result with checksum, return 1 if matched
 */
int checksum(char *p)
{
	/*
	 * convert checksum to DEC
	 */ 
	char *sums = strchr(p, '*') + 1;
	char *s = sums;
	int sum = 0;
	int i;
	for (i = strlen(sums) - 1; i >= 0; i--) {
		int fact = 0;
		if (*s >= '0' && *s <= '9') {
			fact = *s - 48;
		} else if (*s >= 'A' && *s <= 'F') {
			fact = *s - 55;
		} else if (*s >= 'a' && *s <= 'f') {
			fact = *s - 87;	
		}
		s++;
		sum = sum + fact * pow(16, i);
	}
	
	/*
	 * XOR
	 */ 
	char *x = strchr(p, '$') + 1;
	int xor = 0;
	while (*x != '*') {
		xor = xor ^ *x++;
	}
	xor = xor % 65536;
	
	return (xor == sum);
}

/*
 * Return the location marker
 */
char located(char *p)
{
	char *loc2 = strchr((strchr(p, ',') +1), ',');
	return *(loc2+1);	
}

void utc_bjt(int utc_h, int m, int s)
{
	int bjt_h;
	if (utc_h >= 16) {
		bjt_h = utc_h + 8 - 24;
	} else {
		bjt_h = utc_h + 8;
	}
	
	if (bjt_h < 10) {
		printf("0%d:", bjt_h);
	} else {
		printf("%d:", bjt_h);
	}
	
	if (m < 10) {
		printf("0%d:", m);
	} else {
		printf("%d:", m);
	}
	
	if (s < 10) {
		printf("0%d", s);
	} else {
		printf("%d", s);
	}
}
```

**输出一个数的二进制**
```
#include <stdio.h>

int main(int argc, char const *argv[])
{
	int number;
	scanf("%d", &number);
	unsigned mask = 1u<<31;
	for ( ; mask; mask >>=1) {
		printf("%d", number & mask ? 1 : 0);
	}
	printf("\n");
	
	return 0;
}
```

**构造素数表**



**结构化程序设计方法的主要原则**

- 自顶向下
- 逐步求精
- 模块化
- 限制使用goto语句 

# 测试题

1. 下面程序段的输出结果是？
    ```c
    int k;
    while(k!=0) k=k-1;
    printf("%d", k);
    ```
- [x] A. 无论 k 的初值如何，最终都会减到 0 的
- [ ] B. 1
- [ ] C. 因为没有给 k 赋初值，因此程序不能通过编译
- [ ] D. 因为 k 没有初值，所以结果不确定

2. 下列四个叙述中，正确的是？
- [ ] A. C 程序中的所有字母都必须小写
- [x] B. C 语言所有的关键字都是小写的
- [ ] C. C 程序中的关键字必须小写，其他标示符不区分大小写
- [ ] D. C 语言不区分大小写

3. 对于以下代码段，正确的说法是：
    ```c
    char *p;
    while (1) {
        p = malloc(1);
        *p = 0;
    }
    ```
    - [ ] A. 最终程序会因为没有没有空间了而退出
    - [x] B. 最终程序会因为向0地址写入而退出
    - [ ] C. 程序会一直运行下去
    - [ ] D. 程序不能被编译
    
    解析：malloc在分配内存失败时并不会终止程序，而是返回NULL指针。而第4行代码试图向NULL指针位置写入数据，这会引起程序终止（通常操作系统会因为“段错误”而终止程序）。

4. 循环语句 while (!x&&!y) 中的循环条件表达式等价于
    - [ ] A. !(x==0 || y==0)
    - [x] B. !(x!=0||y!=0)
    - [ ] C. !(x==0 && y==0)
    - [ ] D. x=0 && y=0

5. 与 `while( *s++ = *t++ );` 等价的程序段是
    - [X] A. 
    ```c
    do { 
        *s = *t++;  
    } while ( *s++ );
    ```
    - [ ] B. 
    ```c
    while ( *t ) 
       *s++ = *t++;
    ```
    - [ ] C. 
    ```c
    while ( *s ) 
        *s++ = *t++;
    ```
    - [ ] D. 
    ```c
    do { 
        *s++ = *t++;  
    } while ( *t  );
    ```
6. 用 typedef 写出类型定义语句，使得STR表示字符指针类型:
    `typedef char* STR;`

4. 以下代码段的输出是：
    ```c
    int x, y, z, w;
    void p(int *y, int x)
    {
        static int w;
        *y++; x++; w = x+*--y;
        printf("%d#%d#%d#%d#",x,*y,z,w);
    }
    int main(void)
    {
        int x, y, z, w;
        x=y=z=w=1;
        do{
            static int x;
            p(&x, y);
            printf("%d#%d#%d#%d#",x,y,z,w);
        } while(0);
        return 0;
    }
    ```
    2#0#0#2#0#1#1#1#


# 疑难问题

1. 计算机是如何把二进制转换为十进制进行输出的？也是加权计算吗？如果这样的话那最小的负数，比如 10000 0000 0000 0000 如何输出成 -32768？
2. 

# 常用数学函数

`#include <math.h>`
平方根函数：sqrt (x)
绝对值函数：fabs (x)
幂函数：pow (x, n)
指数函数： exp (x)
以 e 为底的对数函数log (x)

# 代码风格

给变量起名尽量做到“见名知义”，使别人一看到变量名就知道它的含义。
变量名中的英文字母习惯用小写字母。

Tips: 在if和else后面总是用{}，即使只有一条语句的时候：
- 以后加代码到if语句里的话会很方便
- 容易捕捉到哪些代码是一块的，很容易的通过注释理解这一块代码的功能是什么

Tips: 单一出口
Tips: 不要把赋值，包括复合赋值组合进逻辑运算表达式
Tips: 不要使⽤嵌套的条件表达式


# Tips

返回指针的函数
• 返回本地变量的地址是危险的
• 返回全局变量或静态本地变量的地址是安全的
• 返回在函数内malloc的内存是安全的，但是容易造成问题
• 最好的做法是返回传⼊的指针

• 不要使⽤全局变量来在函数间传递参数和结果
• 尽量避免使⽤全局变量
• 丰⽥汽⻋的案⼦
• ＊使⽤全局变量和静态本地变量的函数是线程不安全的


[^footnote]:
C语言中的9中控制语句
goto语句:无条件转向; 
if语句:判断语句; 
while循环语句; 
do-while语句:先执行循环体,然后判断循环条件是否成立. 之后继续循环; 
for语句:循环,可替代while语句; 只是用法不同; 
break语句跳出本层的循环;(只跳出包含此语句的循环) 
continue语句:继续(一般放到循环语句里,不在执行它下面的语句,直接跳到判断语句例:for语句,就直接跳到第二个分号处,while语句,就直接跳到while()的括号里; 
switch语句:多相选择; 
return语句:返回;

[^footnote2]:
ANSI C 共有32个关键字：auto break case char const continue default do double else enum extern float for goto if int long register return short signed sizeof static struct switch typedef union unsigned void volatile while
C99 标准新增了5个关键字：inline restrict _Bool _Complex _Imaginary
C11 标准新增了7个关键字：_Alignas _Alignof _Atomic _Static_assert _Noreturn _Thread_local _Generic
